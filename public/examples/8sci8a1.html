<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Liquid Conductivity Simulation</title>
        <style>
            body {
                margin: 0;
                overflow: hidden;
            }
            canvas {
                display: block;
            }
            .ui {
                position: absolute;
                top: 10px;
                left: 10px;
                background: rgba(0, 0, 0, 0.7);
                color: white;
                padding: 10px;
                border-radius: 5px;
                font-family: Arial, sans-serif;
            }
            select,
            button {
                margin: 5px 0;
                padding: 5px;
            }
        </style>
    </head>
    <body>
        <div class="ui">
            <h2>Liquid Conductivity Simulator</h2>
            <select id="liquidType">
                <option value="pureWater">
                    Distilled Water (Non-conductive)
                </option>
                <option value="tapWater">Tap Water (Low Conductivity)</option>
                <option value="saltWater">Salt Water (Conductive)</option>
                <option value="sugarWater">Sugar Water (Non-conductive)</option>
                <option value="vinegar">Vinegar (Weak Acid)</option>
                <option value="lemonJuice">Lemon Juice (Weak Acid)</option>
                <option value="bakingSoda">
                    Baking Soda Solution (Weak Base)
                </option>
                <option value="alcohol">Alcohol (Non-conductive)</option>
                <option value="milk">Milk (Low Conductivity)</option>
                <option value="hydrogenPeroxide">
                    Hydrogen Peroxide (Low Conductivity)
                </option>
                <option value="acid">
                    Strong Acid (HCl, Highly Conductive)
                </option>
                <option value="base">
                    Strong Base (NaOH, Highly Conductive)
                </option>
                <option value="oil">Oil (Non-conductive)</option>
                <option value="sportsDrink">Sports Drink (Electrolytes)</option>
            </select>
            <button id="powerBtn">Toggle Power</button>
            <div id="conductivityInfo">Current: 0 mA</div>
            <div
                id="liquidInfo"
                style="margin-top: 8px; font-size: 0.95em"
            ></div>
        </div>

        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.1/gsap.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
        <script>
            // Overlay mesh handles for shimmer/glow effects
            let oilShimmer = null;
            let acidGlow = null;
            let baseGlow = null;

            // Utility for text sprites (ion charge labels)
            function makeTextSprite(message, parameters) {
                if (parameters === undefined) parameters = {};
                var fontface = parameters.hasOwnProperty("fontface")
                    ? parameters["fontface"]
                    : "Arial";
                var fontsize = parameters.hasOwnProperty("fontsize")
                    ? parameters["fontsize"]
                    : 32;
                var borderThickness = parameters.hasOwnProperty(
                    "borderThickness",
                )
                    ? parameters["borderThickness"]
                    : 2;
                var borderColor = parameters.hasOwnProperty("borderColor")
                    ? parameters["borderColor"]
                    : { r: 0, g: 0, b: 0, a: 1.0 };
                var backgroundColor = parameters.hasOwnProperty(
                    "backgroundColor",
                )
                    ? parameters["backgroundColor"]
                    : { r: 255, g: 255, b: 255, a: 0.0 };

                var canvas = document.createElement("canvas");
                var context = canvas.getContext("2d");
                context.font = fontsize + "px " + fontface;

                // get size data (height depends only on font size)
                var metrics = context.measureText(message);
                var textWidth = metrics.width;

                // background color
                context.fillStyle =
                    "rgba(" +
                    backgroundColor.r +
                    "," +
                    backgroundColor.g +
                    "," +
                    backgroundColor.b +
                    "," +
                    backgroundColor.a +
                    ")";
                // border color
                context.strokeStyle =
                    "rgba(" +
                    borderColor.r +
                    "," +
                    borderColor.g +
                    "," +
                    borderColor.b +
                    "," +
                    borderColor.a +
                    ")";
                context.lineWidth = borderThickness;
                // Draw background rect
                context.fillRect(
                    borderThickness / 2,
                    borderThickness / 2,
                    textWidth + borderThickness,
                    fontsize * 1.2 + borderThickness,
                );
                // Draw border rect
                context.strokeRect(
                    borderThickness / 2,
                    borderThickness / 2,
                    textWidth + borderThickness,
                    fontsize * 1.2 + borderThickness,
                );
                // text color
                context.fillStyle = "rgba(0, 0, 0, 1.0)";
                context.fillText(
                    message,
                    borderThickness,
                    fontsize + borderThickness / 2,
                );

                // canvas contents will be used for a texture
                var texture = new THREE.Texture(canvas);
                texture.needsUpdate = true;

                var spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                var sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(0.18, 0.09, 1.0);
                return sprite;
            }
            // Main simulation code
            document.addEventListener("DOMContentLoaded", function () {
                // Scene setup
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000,
                );
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                document.body.appendChild(renderer.domElement);

                // Add OrbitControls for interactive camera movement
                const controls = new THREE.OrbitControls(
                    camera,
                    renderer.domElement,
                );
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(
                    0xffffff,
                    0.8,
                );
                directionalLight.position.set(1, 1, 1);
                scene.add(directionalLight);

                // Container for the liquid
                const containerGeometry = new THREE.CylinderGeometry(
                    2,
                    2,
                    3,
                    32,
                );
                const containerMaterial = new THREE.MeshPhongMaterial({
                    color: 0xcccccc,
                    transparent: true,
                    opacity: 0.7,
                    refractionRatio: 0.9,
                });
                const container = new THREE.Mesh(
                    containerGeometry,
                    containerMaterial,
                );
                scene.add(container);

                // Electrodes
                const electrodeGeometry = new THREE.BoxGeometry(0.2, 2, 0.2);
                const electrodeMaterial = new THREE.MeshPhongMaterial({
                    color: 0x999999,
                });

                const leftElectrode = new THREE.Mesh(
                    electrodeGeometry,
                    electrodeMaterial,
                );
                leftElectrode.position.set(-1.5, 0, 0);
                scene.add(leftElectrode);

                const rightElectrode = new THREE.Mesh(
                    electrodeGeometry,
                    electrodeMaterial,
                );
                rightElectrode.position.set(1.5, 0, 0);
                scene.add(rightElectrode);

                // Liquid particles (ions for conductive liquids)
                let liquidParticles = [];
                const particleGroup = new THREE.Group();
                scene.add(particleGroup);

                // Circuit elements (realistic layout)
                // Battery at back, ammeter to the left, wires connect in series to electrodes
                const battery = createBattery();
                battery.position.set(0, 3, -5); // Move battery further back
                scene.add(battery);

                // Ammeter in series between battery (+) and left electrode
                const ammeter = createAmmeter();
                ammeter.position.set(-2, 3, -4); // Place ammeter between battery and left wire
                scene.add(ammeter);

                // Wire from battery (+) terminal to ammeter
                const wire_batt_to_amm = createWire(
                    [0.3, 3.4, -5],
                    [-1.7, 3.4, -4],
                    0.05,
                ); // + terminal is at y+ on battery
                scene.add(wire_batt_to_amm);

                // Wire from ammeter to top of left electrode
                const wire_amm_to_left = createWire(
                    [-1.7, 3.4, -4],
                    [-1.5, 1, 0],
                    0.05,
                );
                scene.add(wire_amm_to_left);

                // Wire from top of right electrode to battery (–) terminal
                const wire_right_to_batt = createWire(
                    [1.5, 1, 0],
                    [-0.3, 2.6, -5],
                    0.05,
                ); // – terminal is at y- on battery
                scene.add(wire_right_to_batt);

                // (Optional) Short wire from battery (–) terminal to close the loop
                // const wire_batt_neg = createWire([-0.3, 2.6, -5], [0, 2.6, -5], 0.05);
                // scene.add(wire_batt_neg);

                // Camera position
                camera.position.set(0, 2, 5);
                camera.lookAt(0, 0, 0);
                controls.target.set(0, 0, 0);
                controls.update();

                // Animation variables
                let powerOn = false;
                let currentLiquidType = "pureWater";
                let currentFlow = 0;
                const conductivityInfo =
                    document.getElementById("conductivityInfo");

                // UI event listeners
                document
                    .getElementById("liquidType")
                    .addEventListener("change", function (e) {
                        currentLiquidType = e.target.value;
                        changeLiquid(currentLiquidType);
                    });

                document
                    .getElementById("powerBtn")
                    .addEventListener("click", function () {
                        powerOn = !powerOn;
                        updateCircuit();
                    });

                // Change liquid function
                // Liquid properties: color, opacity, particle/ion info, and educational info
                const liquidProperties = {
                    pureWater: {
                        color: 0x3399ff,
                        opacity: 0.5,
                        particleColor: 0x5555ff,
                        particleCount: 500,
                        particleSize: 0.05,
                        ions: 0,
                        info: "Distilled water contains almost no ions, so it does not conduct electricity.",
                    },
                    tapWater: {
                        color: 0x66bfff,
                        opacity: 0.55,
                        particleColor: 0x88bbff,
                        particleCount: 600,
                        particleSize: 0.05,
                        ions: 0.05,
                        info: "Tap water contains dissolved minerals and ions, so it conducts electricity weakly.",
                    },
                    saltWater: {
                        color: 0x66ccff,
                        opacity: 0.7,
                        particleColor: 0x5555ff,
                        particleCount: 1000,
                        particleSize: 0.05,
                        ions: 0.2,
                        info: "Salt water contains Na⁺ and Cl⁻ ions, making it a strong conductor.",
                    },
                    sugarWater: {
                        color: 0xcce6ff,
                        opacity: 0.6,
                        particleColor: 0x99ccff,
                        particleCount: 700,
                        particleSize: 0.05,
                        ions: 0,
                        info: "Sugar dissolves but does not form ions, so sugar water does not conduct electricity.",
                    },
                    vinegar: {
                        color: 0xf7e6b2,
                        opacity: 0.6,
                        particleColor: 0xf7e6b2,
                        particleCount: 700,
                        particleSize: 0.05,
                        ions: 0.08,
                        info: "Vinegar is a weak acid (acetic acid), so it conducts electricity moderately.",
                    },
                    lemonJuice: {
                        color: 0xfff799,
                        opacity: 0.6,
                        particleColor: 0xfff799,
                        particleCount: 700,
                        particleSize: 0.05,
                        ions: 0.09,
                        info: "Lemon juice contains citric acid, a weak acid, so it conducts moderately.",
                    },
                    bakingSoda: {
                        color: 0xe6f7ff,
                        opacity: 0.6,
                        particleColor: 0xe6f7ff,
                        particleCount: 700,
                        particleSize: 0.05,
                        ions: 0.09,
                        info: "Baking soda solution is a weak base and conducts electricity moderately.",
                    },
                    alcohol: {
                        color: 0xfffbe6,
                        opacity: 0.5,
                        particleColor: 0xfffbe6,
                        particleCount: 600,
                        particleSize: 0.05,
                        ions: 0,
                        info: "Alcohol does not form ions in solution, so it does not conduct electricity.",
                    },
                    milk: {
                        color: 0xfafad2,
                        opacity: 0.7,
                        particleColor: 0xfafad2,
                        particleCount: 800,
                        particleSize: 0.06,
                        ions: 0.04,
                        info: "Milk contains some ions and proteins, so it conducts weakly.",
                    },
                    hydrogenPeroxide: {
                        color: 0xe6faff,
                        opacity: 0.6,
                        particleColor: 0xe6faff,
                        particleCount: 700,
                        particleSize: 0.05,
                        ions: 0.01,
                        info: "Hydrogen peroxide is a weak conductor due to limited ionization.",
                    },
                    acid: {
                        color: 0xeaff70,
                        opacity: 0.6,
                        particleColor: 0xff5555,
                        particleCount: 1200,
                        particleSize: 0.04,
                        ions: 0.25,
                        info: "Strong acids (like HCl) dissociate completely, making them excellent conductors.",
                    },
                    base: {
                        color: 0xd0ffe6,
                        opacity: 0.6,
                        particleColor: 0xd0ffe6,
                        particleCount: 1200,
                        particleSize: 0.04,
                        ions: 0.25,
                        info: "Strong bases (like NaOH) dissociate completely, making them excellent conductors.",
                    },
                    oil: {
                        color: 0xffe066,
                        opacity: 0.85,
                        particleColor: 0xffe066,
                        particleCount: 400,
                        particleSize: 0.08,
                        ions: 0,
                        info: "Oil does not contain ions and does not conduct electricity.",
                    },
                    sportsDrink: {
                        color: 0x99e6ff,
                        opacity: 0.65,
                        particleColor: 0x99e6ff,
                        particleCount: 900,
                        particleSize: 0.05,
                        ions: 0.13,
                        info: "Sports drinks contain electrolytes (ions), so they conduct electricity well.",
                    },
                };

                function changeLiquid(type) {
                    // Animate liquid color and opacity for realism
                    const props = liquidProperties[type];
                    gsap.to(container.material.color, {
                        r: ((props.color >> 16) & 0xff) / 255,
                        g: ((props.color >> 8) & 0xff) / 255,
                        b: (props.color & 0xff) / 255,
                        duration: 0.7,
                    });
                    gsap.to(container.material, {
                        opacity: props.opacity,
                        duration: 0.7,
                    });

                    // Remove previous overlays
                    if (oilShimmer) {
                        scene.remove(oilShimmer);
                        oilShimmer = null;
                    }
                    if (acidGlow) {
                        scene.remove(acidGlow);
                        acidGlow = null;
                    }
                    if (baseGlow) {
                        scene.remove(baseGlow);
                        baseGlow = null;
                    }

                    // Add shimmer/glow overlays for oil, acid, base
                    if (type === "oil") {
                        const shimmerGeo = new THREE.PlaneGeometry(3.8, 3.8);
                        const shimmerMat = new THREE.MeshBasicMaterial({
                            color: 0xffffcc,
                            transparent: true,
                            opacity: 0.18,
                        });
                        oilShimmer = new THREE.Mesh(shimmerGeo, shimmerMat);
                        oilShimmer.position.y = 2.0;
                        oilShimmer.rotation.x = -Math.PI / 2;
                        oilShimmer.name = "oilShimmer";
                        scene.add(oilShimmer);
                    }
                    if (type === "acid") {
                        const glowGeo = new THREE.CylinderGeometry(
                            2.01,
                            2.01,
                            1.7,
                            32,
                        );
                        const glowMat = new THREE.MeshBasicMaterial({
                            color: 0xfff700,
                            transparent: true,
                            opacity: 0.18,
                        });
                        acidGlow = new THREE.Mesh(glowGeo, glowMat);
                        acidGlow.position.y = 0;
                        acidGlow.name = "acidGlow";
                        scene.add(acidGlow);
                    }
                    if (type === "base") {
                        const glowGeo = new THREE.CylinderGeometry(
                            2.01,
                            2.01,
                            1.7,
                            32,
                        );
                        const glowMat = new THREE.MeshBasicMaterial({
                            color: 0x00fff7,
                            transparent: true,
                            opacity: 0.14,
                        });
                        baseGlow = new THREE.Mesh(glowGeo, glowMat);
                        baseGlow.position.y = 0;
                        baseGlow.name = "baseGlow";
                        scene.add(baseGlow);
                    }

                    // Show educational info
                    document.getElementById("liquidInfo").textContent =
                        props.info;

                    // Fade out and remove old particles for smooth transition
                    particleGroup.children.forEach((p) => {
                        gsap.to(p.material, {
                            opacity: 0,
                            duration: 0.5,
                            onComplete: () => {
                                particleGroup.remove(p);
                                if (p.userData.chargeLabel) {
                                    particleGroup.remove(
                                        p.userData.chargeLabel,
                                    );
                                }
                            },
                        });
                    });
                    setTimeout(() => {
                        particleGroup.clear();
                        liquidParticles = [];

                        // Create new particles based on liquid type
                        let particleCount = props.particleCount;
                        let particleColor = props.particleColor;
                        let particleSize = props.particleSize;
                        let ionFraction = props.ions;

                        // Neutral molecules
                        for (
                            let i = 0;
                            i < Math.round(particleCount * (1 - ionFraction));
                            i++
                        ) {
                            createParticle(particleColor, particleSize, false);
                        }

                        // Ions for electrolytes
                        if (ionFraction > 0) {
                            const ionCount = Math.round(
                                particleCount * ionFraction,
                            );
                            for (let i = 0; i < ionCount / 2; i++) {
                                createParticle(
                                    0xffffff,
                                    particleSize * 1.2,
                                    true,
                                    "+",
                                ); // Cation
                                createParticle(
                                    0xffff00,
                                    particleSize * 1.2,
                                    true,
                                    "-",
                                ); // Anion
                            }
                        }

                        // Update circuit if power is on
                        if (powerOn) updateCircuit();
                    }, 550); // Wait for fade-out to finish
                }

                function createParticle(
                    color,
                    size,
                    isIon,
                    chargeLabel = null,
                ) {
                    const geometry = new THREE.SphereGeometry(size, 16, 16);
                    const material = new THREE.MeshPhongMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.8,
                        emissive: isIon ? 0x222222 : 0x000000,
                        emissiveIntensity: isIon ? 0.2 : 0,
                    });
                    const particle = new THREE.Mesh(geometry, material);

                    // Random position within container
                    const radius = 1.8 * Math.random();
                    const angle = Math.random() * Math.PI * 2;
                    particle.position.set(
                        radius * Math.cos(angle),
                        -1 + Math.random() * 1.8,
                        radius * Math.sin(angle),
                    );

                    // Store properties
                    particle.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.02,
                            (Math.random() - 0.5) * 0.02,
                            (Math.random() - 0.5) * 0.02,
                        ),
                        isIon: isIon,
                        charge: isIon ? (color === 0xffffff ? 1 : -1) : 0,
                        chargeLabel: null,
                    };

                    // Add charge label sprite for ions
                    if (isIon && chargeLabel) {
                        const sprite = makeTextSprite(chargeLabel, {
                            fontsize: 36,
                            borderThickness: 0,
                            backgroundColor: { r: 255, g: 255, b: 255, a: 0.0 },
                        });
                        sprite.position.set(0, size * 2, 0);
                        particle.add(sprite);
                        particle.userData.chargeLabel = sprite;
                    }

                    particleGroup.add(particle);
                    liquidParticles.push(particle);
                }

                // Update circuit based on power and liquid type
                function updateCircuit() {
                    // Calculate conductivity based on liquid type
                    let conductivity = 0;
                    let maxCurrent = 0;

                    // Assign conductivity and maxCurrent based on new liquid types
                    switch (currentLiquidType) {
                        case "pureWater":
                            conductivity = 0.000005;
                            maxCurrent = 0.1;
                            break;
                        case "tapWater":
                            conductivity = 0.01;
                            maxCurrent = 2;
                            break;
                        case "saltWater":
                            conductivity = 0.5;
                            maxCurrent = 50;
                            break;
                        case "sugarWater":
                            conductivity = 0.00001;
                            maxCurrent = 0.1;
                            break;
                        case "vinegar":
                            conductivity = 0.08;
                            maxCurrent = 8;
                            break;
                        case "lemonJuice":
                            conductivity = 0.09;
                            maxCurrent = 9;
                            break;
                        case "bakingSoda":
                            conductivity = 0.09;
                            maxCurrent = 9;
                            break;
                        case "alcohol":
                            conductivity = 0.00001;
                            maxCurrent = 0.1;
                            break;
                        case "milk":
                            conductivity = 0.04;
                            maxCurrent = 4;
                            break;
                        case "hydrogenPeroxide":
                            conductivity = 0.01;
                            maxCurrent = 1;
                            break;
                        case "acid":
                            conductivity = 2.0;
                            maxCurrent = 200;
                            break;
                        case "base":
                            conductivity = 2.0;
                            maxCurrent = 200;
                            break;
                        case "oil":
                            conductivity = 0.000001;
                            maxCurrent = 0.01;
                            break;
                        case "sportsDrink":
                            conductivity = 0.13;
                            maxCurrent = 13;
                            break;
                    }

                    // Animate current flow
                    if (powerOn) {
                        // Random fluctuation around the max current
                        currentFlow = maxCurrent * (0.9 + Math.random() * 0.2);

                        // Visual effects: subtle glow on active electrodes
                        // For all strong/weak electrolytes, show glow and bubbles
                        if (
                            currentLiquidType === "saltWater" ||
                            currentLiquidType === "acid" ||
                            currentLiquidType === "base" ||
                            currentLiquidType === "vinegar" ||
                            currentLiquidType === "lemonJuice" ||
                            currentLiquidType === "bakingSoda" ||
                            currentLiquidType === "tapWater" ||
                            currentLiquidType === "milk" ||
                            currentLiquidType === "hydrogenPeroxide" ||
                            currentLiquidType === "sportsDrink"
                        ) {
                            // Cathode (left) glows blueish, anode (right) glows greenish
                            gsap.to(leftElectrode.material.color, {
                                r: 0.6,
                                g: 0.8,
                                b: 1.0,
                                duration: 0.5,
                            });
                            gsap.to(rightElectrode.material.color, {
                                r: 0.7,
                                g: 1.0,
                                b: 0.7,
                                duration: 0.5,
                            });
                            createBubbles();
                        } else {
                            // Both electrodes: subtle yellowish for non-electrolytes
                            gsap.to(leftElectrode.material.color, {
                                r: 0.8,
                                g: 0.8,
                                b: 0.2,
                                duration: 0.5,
                            });
                            gsap.to(rightElectrode.material.color, {
                                r: 0.8,
                                g: 0.8,
                                b: 0.2,
                                duration: 0.5,
                            });
                        }

                        // Ammeter display: animate color and digital value
                        if (ammeter.children[1]) {
                            const intensity = Math.min(currentFlow / 200, 1);
                            ammeter.children[1].material.color.setHSL(
                                0.3 * (1 - intensity),
                                1,
                                0.5 * intensity + 0.3,
                            );
                        }
                    } else {
                        currentFlow = 0;

                        // Electrodes return to neutral color
                        gsap.to(rightElectrode.material.color, {
                            r: 0.6,
                            g: 0.6,
                            b: 0.6,
                            duration: 0.5,
                        });

                        gsap.to(leftElectrode.material.color, {
                            r: 0.6,
                            g: 0.6,
                            b: 0.6,
                            duration: 0.5,
                        });

                        // Ammeter display: animate to low
                        if (ammeter.children[1]) {
                            ammeter.children[1].material.color.setHSL(
                                0.3,
                                1,
                                0.3,
                            );
                        }
                    }

                    conductivityInfo.textContent = `Current: ${currentFlow.toFixed(2)} mA`;
                }

                function createBubbles() {
                    // Chemically accurate bubble formation
                    if (!powerOn) return;
                    // Only for electrolytes
                    const bubbleLiquids = [
                        "saltWater",
                        "acid",
                        "base",
                        "vinegar",
                        "lemonJuice",
                        "bakingSoda",
                        "tapWater",
                        "milk",
                        "hydrogenPeroxide",
                        "sportsDrink",
                    ];
                    if (!bubbleLiquids.includes(currentLiquidType)) return;
                    // Bubble rate proportional to current
                    if (
                        Math.random() >
                        Math.min(0.7 + 0.2 * (1 - currentFlow / 200), 0.95)
                    )
                        return;

                    const bubbleGeometry = new THREE.SphereGeometry(0.05, 8, 8);

                    // Cathode (left): H2 bubbles (small, colorless)
                    const h2Material = new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.7,
                    });
                    const bubbleH2 = new THREE.Mesh(bubbleGeometry, h2Material);
                    bubbleH2.position.copy(leftElectrode.position);
                    bubbleH2.position.y += 1;
                    bubbleH2.userData = {
                        velocity: new THREE.Vector3(0, 0.02, 0),
                    };
                    scene.add(bubbleH2);
                    setTimeout(() => {
                        scene.remove(bubbleH2);
                    }, 2000);

                    // Anode (right): O2 or Cl2 bubbles (greenish for Cl2, pale blue for O2)
                    let anodeColor = 0x99ff99; // Default: greenish (Cl2)
                    if (
                        [
                            "vinegar",
                            "lemonJuice",
                            "bakingSoda",
                            "tapWater",
                            "milk",
                            "hydrogenPeroxide",
                            "sportsDrink",
                        ].includes(currentLiquidType)
                    ) {
                        anodeColor = 0xbbeeff; // Pale blue for O2
                    }
                    const anodeMaterial = new THREE.MeshPhongMaterial({
                        color: anodeColor,
                        transparent: true,
                        opacity: 0.6,
                    });
                    const bubbleAnode = new THREE.Mesh(
                        bubbleGeometry,
                        anodeMaterial,
                    );
                    bubbleAnode.position.copy(rightElectrode.position);
                    bubbleAnode.position.y += 1;
                    bubbleAnode.userData = {
                        velocity: new THREE.Vector3(0, 0.02, 0),
                    };
                    scene.add(bubbleAnode);
                    setTimeout(() => {
                        scene.remove(bubbleAnode);
                    }, 2000);
                }

                // Helper functions for circuit components
                function createBattery() {
                    const group = new THREE.Group();

                    // Battery body
                    const bodyGeometry = new THREE.CylinderGeometry(
                        0.3,
                        0.3,
                        0.8,
                        32,
                    );
                    const bodyMaterial = new THREE.MeshPhongMaterial({
                        color: 0x333333,
                    });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    group.add(body);

                    // Terminals
                    const terminalGeometry = new THREE.CylinderGeometry(
                        0.1,
                        0.1,
                        0.2,
                        32,
                    );
                    const positiveMaterial = new THREE.MeshPhongMaterial({
                        color: 0xff3333,
                    });
                    const negativeMaterial = new THREE.MeshPhongMaterial({
                        color: 0x3333ff,
                    });

                    const positiveTerminal = new THREE.Mesh(
                        terminalGeometry,
                        positiveMaterial,
                    );
                    positiveTerminal.position.y = 0.5;
                    group.add(positiveTerminal);

                    const negativeTerminal = new THREE.Mesh(
                        terminalGeometry,
                        negativeMaterial,
                    );
                    negativeTerminal.position.y = -0.5;
                    group.add(negativeTerminal);

                    return group;
                }

                function createWire(startPos, endPos, thickness) {
                    const direction = new THREE.Vector3().subVectors(
                        new THREE.Vector3(...endPos),
                        new THREE.Vector3(...startPos),
                    );
                    const length = direction.length();

                    const geometry = new THREE.CylinderGeometry(
                        thickness,
                        thickness,
                        length,
                        8,
                    );
                    geometry.rotateX(Math.PI / 2);

                    const material = new THREE.MeshPhongMaterial({
                        color: 0xcccccc,
                    });
                    const wire = new THREE.Mesh(geometry, material);

                    wire.position.set(
                        (startPos[0] + endPos[0]) / 2,
                        (startPos[1] + endPos[1]) / 2,
                        (startPos[2] + endPos[2]) / 2,
                    );

                    wire.lookAt(new THREE.Vector3(...endPos));
                    return wire;
                }

                function createAmmeter() {
                    const group = new THREE.Group();

                    // Meter body
                    const bodyGeometry = new THREE.BoxGeometry(0.5, 0.3, 0.3);
                    const bodyMaterial = new THREE.MeshPhongMaterial({
                        color: 0x222222,
                    });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    group.add(body);

                    // Display
                    const displayGeometry = new THREE.PlaneGeometry(0.4, 0.2);
                    const displayMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00aa00,
                        side: THREE.DoubleSide,
                    });
                    const display = new THREE.Mesh(
                        displayGeometry,
                        displayMaterial,
                    );
                    display.position.set(0, 0, 0.16);
                    group.add(display);

                    return group;
                }

                // Animation loop
                function animate() {
                    requestAnimationFrame(animate);

                    // Animate liquid particles
                    liquidParticles.forEach((particle) => {
                        // Brownian motion
                        particle.position.add(particle.userData.velocity);

                        // Boundary checks (container walls)
                        const distanceFromCenter = Math.sqrt(
                            particle.position.x * particle.position.x +
                                particle.position.z * particle.position.z,
                        );

                        if (distanceFromCenter > 1.8) {
                            particle.userData.velocity.x =
                                -particle.userData.velocity.x * 0.8;
                            particle.userData.velocity.z =
                                -particle.userData.velocity.z * 0.8;
                        }

                        if (
                            particle.position.y > 0.8 ||
                            particle.position.y < -1
                        ) {
                            particle.userData.velocity.y =
                                -particle.userData.velocity.y * 0.8;
                        }

                        // For ions in electric field (chemically accurate drift)
                        if (powerOn && particle.userData.isIon) {
                            // Cations (+) move toward leftElectrode, anions (–) toward rightElectrode
                            // Calculate direction based on charge and electrode positions
                            let targetX;
                            if (particle.userData.charge > 0) {
                                targetX = leftElectrode.position.x;
                            } else if (particle.userData.charge < 0) {
                                targetX = rightElectrode.position.x;
                            }
                            // Drift toward target electrode in X, with some randomness
                            const driftStrength = 0.012;
                            const dx = targetX - particle.position.x;
                            const drift = Math.sign(dx) * driftStrength;
                            particle.userData.velocity.x += drift;

                            // Limit speed for realism
                            if (particle.userData.velocity.length() > 0.1) {
                                particle.userData.velocity
                                    .normalize()
                                    .multiplyScalar(0.1);
                            }
                        }

                        // Random motion
                        particle.userData.velocity.add(
                            new THREE.Vector3(
                                (Math.random() - 0.5) * 0.001,
                                (Math.random() - 0.5) * 0.001,
                                (Math.random() - 0.5) * 0.001,
                            ),
                        );
                    });

                    // Update ammeter display color based on current
                    if (ammeter.children[1]) {
                        const intensity = Math.min(currentFlow / 50, 1);
                        ammeter.children[1].material.color.setHSL(
                            0.3 * (1 - intensity),
                            1,
                            0.5 * intensity,
                        );
                    }

                    renderer.render(scene, camera);
                }

                // Initialize with pure water
                changeLiquid("pureWater");
                animate();

                // Handle window resize
                window.addEventListener("resize", function () {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
            });
        </script>
    </body>
</html>
